
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
RegTech Assistant ‚Äì Streamlit app
---------------------------------

The same code works on Streamlit Cloud (GitHub‚Äëmounted) **and** on a local
machine.  No modifications are required to switch between the two
environments.

Prerequisites
~~~~~~~~~~~~~
pip install -r requirements.txt          # streamlit, langchain, pypdf,
                                         # python-docx, pillow, pytesseract,
                                         # requests
# Optional OCR support:
#   Linux:   sudo apt-get install tesseract-ocr
#   macOS:   brew install tesseract

Set your DeepSeek API key as an environment variable
`DEEPSEEK_API_KEY` **or** in `.streamlit/secrets.toml`:

    DEEPSEEK_API_KEY = "sk-..."

Run:
    streamlit run app.py
"""

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Imports
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
from __future__ import annotations

import os
import re
import json
import time
import datetime
import requests
from typing import List, Dict, Generator, Optional, Tuple

import streamlit as st

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Optional heavy libraries (PDF, DOCX, OCR)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
try:
    from langchain_core.documents import Document
    import pypdf
    import docx
    from PIL import Image
    import pytesseract
    LIBRARIES_AVAILABLE = True
except Exception as e:                     # catches ImportError and any runtime errors
    st.error(f"‚ùó ŸÖŸÉÿ™ÿ®ÿ© ŸÜÿßŸÇÿµÿ© ÿ£Ÿà ÿ∫Ÿäÿ± ŸÖŸèÿ´ÿ®ÿ™ÿ©: {e}")
    LIBRARIES_AVAILABLE = False

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Configuration ‚Äì paths are resolved dynamically
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def get_repo_root() -> str:
    """
    Detect the repository root.

    1Ô∏è‚É£ Cloud layout: the repo is mounted under /mount/src/<repo_name>/.
        Walk upwards until a folder containing `13.RegTech` is found.

    2Ô∏è‚É£ Fallback: assume the script is running locally and return the
        directory that contains this file.
    """
    cwd = os.path.abspath(os.path.dirname(__file__))
    candidate = cwd
    for _ in range(5):
        if os.path.isdir(os.path.join(candidate, "13.RegTech")):
            return candidate
        candidate = os.path.abspath(os.path.join(candidate, ".."))
    return cwd   # local development fallback

# Resolve the root once ‚Äì used everywhere else
REPO_ROOT = get_repo_root()

# Fixed sub‚Äëfolders (relative to the detected root)
FOLDER_PATH = os.path.join(REPO_ROOT, "13.RegTech", "legal_docs")
SUMMARY_FOLDER_PATH = os.path.join(REPO_ROOT, "13.RegTech", "summary")
RULES_FILE_NAME = "RULES.txt"
RULES_FILE_PATH = os.path.join(REPO_ROOT, "13.RegTech", RULES_FILE_NAME)

# API configuration
DEEPSEEK_API_URL = "https://api.deepseek.com/chat/completions"
API_KEY = os.getenv("DEEPSEEK_API_KEY") or st.secrets.get("DEEPSEEK_API_KEY", "")

# Feature flags ---------------------------------------------------------------
USE_AUTO_SUMMARIZATION = True
USE_SUMMARY_FOR_SELECTION = True
USE_TWO_STEP_SELECTION = True
SELECTION_MAX_RETRIES = 3
MAX_DOCS_FOR_SELECTION = 1   # strict limit as requested

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Helper utilities
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def safe_run(fn):
    """Wrap the whole Streamlit app so uncaught exceptions are shown, not fatal."""
    def wrapper(*args, **kwargs):
        try:
            return fn(*args, **kwargs)
        except Exception as exc:
            st.error(f"‚ùó ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ: {exc}")
            st.exception(exc)
    return wrapper


def read_file_content(file_path: str) -> Tuple[str, str]:
    """Read text from PDF, DOCX, TXT, or image (OCR). Returns (file_name, text)."""
    text = ""
    file_name = os.path.basename(file_path)

    try:
        with open(file_path, "rb") as f:
            if file_name.lower().endswith(".pdf"):
                reader = pypdf.PdfReader(f)
                for page in reader.pages:
                    text += page.extract_text() or ""
            elif file_name.lower().endswith(".docx"):
                doc = docx.Document(f)
                for para in doc.paragraphs:
                    text += para.text + "\n"
            elif file_name.lower().endswith((".png", ".jpg", ".jpeg")):
                try:
                    text = pytesseract.image_to_string(Image.open(f))
                except pytesseract.TesseractNotFoundError:
                    st.error("‚ùó Tesseract ÿ∫Ÿäÿ± ŸÖŸèÿ´ÿ®ÿ™ ÿπŸÑŸâ ÿßŸÑÿ¨Ÿáÿßÿ≤.")
                except Exception as ocr_e:
                    st.error(f"‚ùó ŸÅÿ¥ŸÑ ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑÿµŸàÿ±ÿ© {file_name}: {ocr_e}")
            else:   # txt or any other plain‚Äëtext fallback
                with open(file_path, "r", encoding="utf-8") as txt_f:
                    text = txt_f.read()
    except Exception as e:
        st.error(f"‚ùó ÿÆÿ∑ÿ£ ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑŸÖŸÑŸÅ {file_name}: {e}")

    return file_name, text


def get_document_names_from_folder(folder_path: str) -> List[str]:
    """Return a list of supported document names inside *folder_path*."""
    if not os.path.isdir(folder_path):
        st.warning(f"‚ö†Ô∏è ÿßŸÑŸÖÿ¨ŸÑÿØ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ: {folder_path}")
        return []

    supported = [
        f for f in os.listdir(folder_path)
        if f != RULES_FILE_NAME and f.lower().endswith(
            (".pdf", ".docx", ".txt", ".png", ".jpg", ".jpeg")
        )
    ]
    return supported


def load_rules_file(rules_path: str) -> str:
    """Load the RULES.txt file (or return a default message)."""
    if os.path.exists(rules_path):
        _, content = read_file_content(rules_path)
        return content
    return "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿÆÿßÿµÿ©. ÿßÿ™ÿ®ÿπ ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©."


def get_deepseek_response_blocking(prompt: str, api_key: str) -> Optional[str]:
    """Call DeepSeek once (non‚Äëstreaming) and return the answer."""
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
    }
    payload = {
        "model": "deepseek-chat",
        "messages": [{"role": "user", "content": prompt}],
        "stream": False,
    }

    try:
        response = requests.post(
            DEEPSEEK_API_URL,
            headers=headers,
            json=payload,
            timeout=90,
        )
        response.raise_for_status()
        data = response.json()
        return data["choices"][0]["message"]["content"]
    except requests.RequestException as e:
        st.error(f"‚ùó ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑŸÄ API: {e}")
    except Exception as e:
        st.error(f"‚ùó ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ ÿπŸÜÿØ ÿ∑ŸÑÿ® ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©: {e}")
    return None


def generate_and_save_summary(
    file_name: str,
    doc_folder: str,
    summary_folder: str,
    api_key: str,
) -> None:
    """Create a one‚Äëparagraph summary for *file_name* if it does not exist."""
    summary_file = f"{os.path.splitext(file_name)[0]}_summary.txt"
    summary_path = os.path.join(summary_folder, summary_file)

    if os.path.exists(summary_path):
        return  # already cached

    st.info(f"‚ùì ŸÑŸÖ ŸäŸèÿπÿ´ÿ± ÿπŸÑŸâ ŸÖŸÑÿÆÿµ ŸÑŸÄ `{file_name}`. ÿ¨ÿßÿ±Ÿç ÿ•ŸÜÿ¥ÿßÿ§Ÿá ÿßŸÑÿ¢ŸÜ‚Ä¶")
    original_path = os.path.join(doc_folder, file_name)
    _, content = read_file_content(original_path)

    if not content.strip():
        st.warning(f"‚ö†Ô∏è ÿßŸÑŸÖŸÑŸÅ `{file_name}` ŸÅÿßÿ±ÿ∫ ÿ£Ÿà ÿ∫Ÿäÿ± ŸÇÿßÿ®ŸÑ ŸÑŸÑŸÇÿ±ÿßÿ°ÿ©.")
        return

    prompt = f"""
ŸÖŸáŸÖÿ™ŸÉ ŸáŸä ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑÿÆÿµ ŸÖŸàÿ¨ÿ≤ ŸÑŸÑŸÖÿ≥ÿ™ŸÜÿØ ÿßŸÑÿ™ÿßŸÑŸä. ÿßŸÉÿ™ÿ® ÿßŸÑŸÖŸÑÿÆÿµ ŸÉŸÅŸÇÿ±ÿ© Ÿàÿßÿ≠ÿØÿ© ŸÖÿ™ÿµŸÑÿ©
ÿ®ÿØŸàŸÜ ŸÜŸÇÿßÿ∑ ÿ£Ÿà ŸÇŸàÿßÿ¶ŸÖ. ŸÑÿß ÿ™ÿ∂ŸÅ ŸÖŸÇÿØŸÖÿßÿ™ ÿ£Ÿà ÿÆÿ™ÿßŸÖÿßÿ™.

ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØ:
{content}
ÿßŸÑŸÖŸÑÿÆÿµ:
""".strip()

    with st.spinner(f"üöß ÿ™ŸàŸÑŸäÿØ ŸÖŸÑÿÆÿµ `{file_name}`‚Ä¶"):
        summary = get_deepseek_response_blocking(prompt, api_key)

    if summary:
        try:
            os.makedirs(summary_folder, exist_ok=True)
            full_text = f"ŸÖŸÑÿÆÿµ ŸÖŸÑŸÅ: {file_name}\n\n{summary}"
            with open(summary_path, "w", encoding="utf-8") as f:
                f.write(full_text)
            st.toast(f"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ŸÖŸÑÿÆÿµ `{file_name}`.", icon="üìù")
        except Exception as e:
            st.error(f"‚ùó ŸÅÿ¥ŸÑ ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑÿÆÿµ: {e}")
    else:
        st.error(f"‚ùó ŸÅÿ¥ŸÑ ÿ™ŸàŸÑŸäÿØ ŸÖŸÑÿÆÿµ ŸÑŸÑŸÖŸÑŸÅ `{file_name}`.")


def load_all_summaries(summary_folder: str) -> str:
    """Concatenate all summary txt files into a single string."""
    if not os.path.isdir(summary_folder):
        return "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸÑÿÆÿµÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ©."

    out = ""
    for fname in sorted(os.listdir(summary_folder)):
        if fname.lower().endswith(".txt"):
            _, txt = read_file_content(os.path.join(summary_folder, fname))
            out += f"---\n{txt}\n---\n\n"
    return out or "ŸÑŸÖ ŸäŸèÿπÿ´ÿ± ÿπŸÑŸâ ŸÖŸÑÿÆÿµÿßÿ™."


def get_document_selection_with_summaries(
    question: str,
    doc_names: List[str],
    rules: str,
    summaries: str,
    api_key: str,
    max_docs: int,
) -> Optional[List[int]]:
    """Ask the LLM to pick the most relevant documents (max *max_docs*)."""
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
    }

    doc_list = "\n".join([f"#{i}: {name}" for i, name in enumerate(doc_names)])

    user_prompt = f"""
ŸÖŸáŸÖÿ™ŸÉ ŸáŸä ÿ™ÿ≠ÿØŸäÿØ ÿ£ŸÜÿ≥ÿ® ÿßŸÑŸÖŸÑŸÅÿßÿ™ ŸÑŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿπŸÑŸâ ÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿå
ÿ®ÿ≠ÿØ ÿ£ŸÇÿµŸâ {max_docs} ŸÖŸÑŸÅ. ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÇŸàÿßÿπÿØ ŸàÿßŸÑŸÖŸÑÿÆÿµÿßÿ™.

ÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:
{question}

ÿßŸÑŸÇŸàÿßÿπÿØ ÿßŸÑÿ•ŸÑÿ≤ÿßŸÖŸäÿ©:
{rules}

ŸÖŸÑÿÆÿµÿßÿ™ ÿßŸÑŸÖŸÑŸÅÿßÿ™:
{summaries}

ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©:
{doc_list}

ÿßŸÑÿ±ÿØ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ£ÿ±ŸÇÿßŸÖ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿÆÿ™ÿßÿ±ÿ© ÿ®ÿµŸäÿ∫ÿ© #N ÿ£Ÿà #NONE ÿ•ÿ∞ÿß ŸÑÿß ÿ¥Ÿäÿ° ŸÖŸÜÿßÿ≥ÿ®.
""".strip()

    payload = {
        "model": "deepseek-chat",
        "messages": [{"role": "user", "content": user_prompt}],
        "stream": False,
    }

    for attempt in range(SELECTION_MAX_RETRIES):
        try:
            resp = requests.post(
                DEEPSEEK_API_URL,
                headers=headers,
                json=payload,
                timeout=45,
            )
            resp.raise_for_status()
            data = resp.json()
            content = data["choices"][0]["message"]["content"]

            found = re.findall(r"#(\d+)", content)

            if found:
                indices = [int(i) for i in found if 0 <= int(i) < len(doc_names)]
                return indices[:max_docs]
            if "#NONE" in content.upper():
                return []
            st.warning(f"‚ö†Ô∏è ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ© ŸÖŸÜ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ({attempt+1}/{SELECTION_MAX_RETRIES})")
            time.sleep(1)
        except Exception as e:
            st.error(f"‚ùó ŸÅÿ¥ŸÑ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ: {e}")
            return None

    st.error("‚ùó ŸÅÿ¥ŸÑ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™.")
    return None


def get_deepseek_response_stream(
    prompt: str,
    api_key: str,
    chat_history: List[Dict[str, str]],
    context_doc_count: int,
) -> Generator[str, None, None]:
    """Yield tokens from DeepSeek's streaming endpoint."""
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
    }
    messages = chat_history + [{"role": "user", "content": prompt}]
    payload = {
        "model": "deepseek-chat",
        "messages": messages,
        "stream": True,
    }

    try:
        resp = requests.post(
            DEEPSEEK_API_URL,
            headers=headers,
            json=payload,
            stream=True,
            timeout=60,
        )
        resp.raise_for_status()

        for line in resp.iter_lines():
            if not line:
                continue
            decoded = line.decode("utf-8")
            if not decoded.startswith("data: "):
                continue
            payload = decoded[6:].strip()
            if payload == "[DONE]":
                continue
            try:
                json_data = json.loads(payload)
                delta = json_data.get("choices", [{}])[0].get("delta", {})
                content = delta.get("content", "")
                if content:
                    yield content
            except json.JSONDecodeError:
                continue
    except requests.HTTPError as e:
        err_msg = f"‚ùó ŸÅÿ¥ŸÑ ÿßÿ™ÿµÿßŸÑ API (ŸÉŸàÿØ {e.response.status_code})."
        if e.response.status_code == 400:
            err_msg += "\nÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖÿÆÿ™ÿßÿ± ÿ±ÿ®ŸÖÿß ŸÉÿ®Ÿäÿ± ÿ¨ÿØŸãÿß."
        st.error(err_msg)
        yield err_msg
    except requests.RequestException as e:
        err_msg = f"‚ùó ŸÅÿ¥ŸÑ ÿßÿ™ÿµÿßŸÑ ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™: {e}"
        st.error(err_msg)
        yield err_msg
    except Exception as e:
        err_msg = f"‚ùó ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ: {e}"
        st.error(err_msg)
        yield err_msg


def build_prompt(
    task_description: str,
    rules: str,
    context: str,
    question: Optional[str] = None,
) -> str:
    """Compose the final LLM prompt."""
    q_section = f"\nÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:\n---\n{question}\n---\n" if question else ""
    return f"""ÿ£ŸÜÿ™ ŸÖÿ≥ÿßÿπÿØ ŸÇÿßŸÜŸàŸÜŸä ŸÖÿ™ÿÆÿµÿµ "RegTech Assistance". ÿßÿ™ÿ®ÿπ ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿ®ÿØŸÇÿ©:

ŸÇŸàÿßÿπÿØ ŸÖŸÑÿ≤ŸÖÿ©:
{rules}

ÿßŸÑŸÖŸáŸÖÿ©:
{task_description}

ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ:
{context if context else "ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿ£Ÿà ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ Ÿàÿ´ÿßÿ¶ŸÇ."}
{q_section}
"""


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Streamlit UI
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@safe_run
def main() -> None:
    # --------------------------------------------------------------------- #
    # Page config ‚Äì must be first Streamlit command
    # --------------------------------------------------------------------- #
    st.set_page_config(
        page_title="RegTech Assistance",
        page_icon="‚öñÔ∏è",
        layout="centered",
    )

    # --------------------------------------------------------------------- #
    # Basic sanity checks
    # --------------------------------------------------------------------- #
    if not LIBRARIES_AVAILABLE:
        st.stop()

    if not API_KEY or not API_KEY.startswith("sk-"):
        st.error("‚ùó ŸÖŸÅÿ™ÿßÿ≠ DeepSeek ÿ∫Ÿäÿ± ŸÖÿ∂ÿ®Ÿàÿ∑ (ŸÖÿ™ÿ∫ŸäŸëÿ± ÿßŸÑÿ®Ÿäÿ¶ÿ© `DEEPSEEK_API_KEY`).")
        st.stop()

    # --------------------------------------------------------------------- #
    # Session state init
    # --------------------------------------------------------------------- #
    for key, default in {
        "messages": [],
        "doc_names": [],
        "rules_content": "",
        "docs_loaded_first_time": False,
        "action": None,
    }.items():
        if key not in st.session_state:
            st.session_state[key] = default

    # --------------------------------------------------------------------- #
    # Title + separator
    # --------------------------------------------------------------------- #
    st.title("RegTech Assistance")
    st.markdown("<hr/>", unsafe_allow_html=True)

    # --------------------------------------------------------------------- #
    # Main chat container
    # --------------------------------------------------------------------- #
    chat_container = st.container()
    with chat_container:
        # ------------------------------------------------- #
        # 1Ô∏è‚É£ First‚Äëtime loading of docs / rules / summaries
        # ------------------------------------------------- #
        if not st.session_state.docs_loaded_first_time:
            with st.spinner("ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ ŸàÿßŸÑŸÇŸàÿßÿπÿØ..."):
                # Create folders if they are missing (ignore errors on read‚Äëonly FS)
                for p in (FOLDER_PATH, SUMMARY_FOLDER_PATH):
                    try:
                        os.makedirs(p, exist_ok=True)
                    except Exception as e:
                        st.warning(f"‚ö†Ô∏è ŸÑÿß ŸäŸÖŸÉŸÜ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖÿ¨ŸÑÿØ {p}: {e}")

                st.session_state.doc_names = get_document_names_from_folder(FOLDER_PATH)
                st.session_state.rules_content = load_rules_file(RULES_FILE_PATH)
                st.session_state.docs_loaded_first_time = True
                st.toast(
                    f"‚úÖ ÿπŸèÿ´ÿ± ÿπŸÑŸâ {len(st.session_state.doc_names)} Ÿàÿ´ŸäŸÇÿ©.", icon="‚úÖ"
                )

            # ----- Auto‚Äësummarize if the flag is on -----
            if USE_AUTO_SUMMARIZATION and st.session_state.doc_names:
                st.write("üßê ŸÅÿ≠ÿµ ÿßŸÑŸÖŸÑÿÆÿµÿßÿ™ Ÿàÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÜÿßŸÇÿµÿ© ‚Ä¶")
                prog = st.progress(0)
                for i, name in enumerate(st.session_state.doc_names):
                    generate_and_save_summary(
                        name, FOLDER_PATH, SUMMARY_FOLDER_PATH, API_KEY
                    )
                    prog.progress((i + 1) / len(st.session_state.doc_names))
                prog.empty()

        # ------------------------------------------------- #
        # 2Ô∏è‚É£ Action UI ‚Äì Upload / Summarize
        # ------------------------------------------------- #
        if st.session_state.action == "upload_doc":
            uploaded_file = st.file_uploader(
                "ÿßÿÆÿ™ÿ± ŸÖŸÑŸÅŸãÿß ŸÑÿ™ÿ≠ŸÖŸäŸÑŸá ÿ•ŸÑŸâ ŸÇÿßÿπÿØÿ© ÿßŸÑŸÖÿπÿ±ŸÅÿ©",
                type=["pdf", "docx", "txt", "png", "jpg", "jpeg"],
            )
            if uploaded_file:
                target_path = os.path.join(FOLDER_PATH, uploaded_file.name)
                try:
                    with open(target_path, "wb") as f:
                        f.write(uploaded_file.getbuffer())
                    st.toast(f"‚úÖ ÿ™ŸÖ ÿ±ŸÅÿπ `{uploaded_file.name}`", icon="‚úÖ")
                    if USE_AUTO_SUMMARIZATION:
                        generate_and_save_summary(
                            uploaded_file.name,
                            FOLDER_PATH,
                            SUMMARY_FOLDER_PATH,
                            API_KEY,
                        )
                except Exception as e:
                    st.error(f"‚ùó ŸÅÿ¥ŸÑ ÿ±ŸÅÿπ ÿßŸÑŸÖŸÑŸÅ (ÿßŸÑŸÇÿ±ÿµ ÿ±ÿ®ŸÖÿß ŸÑŸÑŸÇÿ±ÿßÿ°ÿ© ŸÅŸÇÿ∑): {e}")

                # Force a reload of the doc list
                st.session_state.docs_loaded_first_time = False
                st.session_state.action = None
                st.rerun()

        if st.session_state.action == "summarize_doc":
            if st.session_state.doc_names:
                selected = st.selectbox(
                    "ÿßÿÆÿ™ÿ± ŸÖŸÑŸÅŸãÿß ŸÑÿ™ŸÑÿÆŸäÿµŸá:",
                    options=st.session_state.doc_names,
                    index=None,
                    placeholder="ÿßÿÆÿ™ÿ± ŸÖŸÑŸÅ ‚Ä¶",
                )
                if selected:
                    st.session_state.messages.append(
                        {"role": "user", "content": f"ŸÑÿÆÿµ ŸÑŸä ÿßŸÑŸÖŸÑŸÅ: `{selected}`"}
                    )
                    st.session_state.action = "processing_summary"
                    st.session_state.summarize_file = selected
                    st.rerun()
            else:
                st.warning("‚ö†Ô∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ Ÿàÿ´ÿßÿ¶ŸÇ ŸÑÿ™ŸÑÿÆŸäÿµŸáÿß.")
                st.session_state.action = None

        # ------------------------------------------------- #
        # 3Ô∏è‚É£ Display chat history
        # ------------------------------------------------- #
        if not st.session_state.messages:
            st.markdown(
                "<div style='text-align:center;color:#a0a0a0'>ŸÖÿ±ÿ≠ÿ®ÿßŸã! ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ŸÅŸä Ÿàÿ´ÿßÿ¶ŸÇŸÉ ÿßŸÑŸäŸàŸÖÿü ‚öñÔ∏è</div>",
                unsafe_allow_html=True,
            )
        for msg in st.session_state.messages:
            with st.chat_message(msg["role"]):
                if msg.get("is_review_notice"):
                    st.info(msg["content"])
                else:
                    st.markdown(msg["content"])

        # ------------------------------------------------- #
        # 4Ô∏è‚É£ Process assistant actions
        # ------------------------------------------------- #
        if st.session_state.action == "processing_summary":
            with st.chat_message("assistant"):
                file_name = st.session_state.summarize_file
                with st.spinner(f"ÿ¨ÿßÿ±Ÿä ÿ™ŸÑÿÆŸäÿµ `{file_name}`‚Ä¶"):
                    _, text = read_file_content(os.path.join(FOLDER_PATH, file_name))
                    if text:
                        task = "ŸÑÿÆÿµ ÿßŸÑŸàÿ´ŸäŸÇÿ© ÿ®ÿØŸÇÿ© Ÿàÿßÿ∞ŸÉÿ± ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©."
                        context = f"ÿßŸÑŸÖÿµÿØÿ±: {file_name}\n\nÿßŸÑŸÖÿ≠ÿ™ŸàŸâ: {text}"
                        prompt = build_prompt(
                            task, st.session_state.rules_content, context
                        )
                        placeholder = st.empty()
                        full_resp = ""
                        for chunk in get_deepseek_response_stream(
                            prompt, API_KEY, [], 1
                        ):
                            full_resp += chunk
                            placeholder.markdown(full_resp + "‚ñå")
                        placeholder.markdown(full_resp)
                        st.session_state.messages.append(
                            {"role": "assistant", "content": full_resp}
                        )
                    else:
                        err = f"‚ùó ŸÑÿß ŸäŸÖŸÉŸÜ ŸÇÿ±ÿßÿ°ÿ© ŸÖÿ≠ÿ™ŸàŸâ `{file_name}`."
                        st.error(err)
                        st.session_state.messages.append(
                            {"role": "assistant", "content": err}
                        )
            st.session_state.action = None
            st.session_state.summarize_file = None
            time.sleep(0.1)
            st.rerun()

        # ------------------------------------------------- #
        # 5Ô∏è‚É£ New user query
        # ------------------------------------------------- #
        if prompt := st.chat_input(
            "ÿßÿ≥ÿ£ŸÑ ÿ≥ÿ§ÿßŸÑÿßŸã ÿπŸÜ ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ŸÉ ‚Ä¶",
            disabled=(st.session_state.action is not None),
        ):
            st.session_state.messages.append({"role": "user", "content": prompt})
            with st.chat_message("assistant"):
                final_context = ""
                context_docs: List[Document] = []

                # ---- 2‚Äëstep selection (if enabled) ----
                if USE_TWO_STEP_SELECTION and st.session_state.doc_names:
                    with st.spinner("ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸàÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ‚Ä¶"):
                        all_summaries = load_all_summaries(SUMMARY_FOLDER_PATH)
                        selected_idxs = get_document_selection_with_summaries(
                            prompt,
                            st.session_state.doc_names,
                            st.session_state.rules_content,
                            all_summaries,
                            API_KEY,
                            MAX_DOCS_FOR_SELECTION,
                        )

                    if selected_idxs is None:
                        err = "‚ùó ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ."
                        st.error(err)
                        st.session_state.messages.append(
                            {"role": "assistant", "content": err}
                        )
                        st.rerun()
                    elif not selected_idxs:
                        st.info("‚öôÔ∏è ŸÑŸÖ ÿ™Ÿèÿ≠ÿØŸëŸéÿØ Ÿàÿ´ÿßÿ¶ŸÇ ÿ∞ÿßÿ™ ÿµŸÑÿ© ‚Äì ÿ≥ŸäŸèÿ≥ÿ™ŸÜÿØ ÿßŸÑÿ±ÿØ ÿ•ŸÑŸâ ÿßŸÑŸÇŸàÿßÿπÿØ ŸÅŸÇÿ∑.")
                    else:
                        selected_names = [
                            st.session_state.doc_names[i]
                            for i in selected_idxs
                            if 0 <= i < len(st.session_state.doc_names)
                        ]
                        notice = "ÿ≥ÿ£ÿ±ÿßÿ¨Ÿêÿπ ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ ÿßŸÑÿ™ÿßŸÑŸäÿ©:\n\n" + "\n".join(
                            f"- `{n}`" for n in selected_names
                        )
                        st.info(notice)
                        st.session_state.messages.append(
                            {
                                "role": "assistant",
                                "content": notice,
                                "is_review_notice": True,
                            }
                        )
                        with st.spinner("ÿ™ÿ≠ŸÖŸäŸÑ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ ÿßŸÑŸÖÿÆÿ™ÿßÿ±ÿ©‚Ä¶"):
                            for n in selected_names:
                                _, txt = read_file_content(os.path.join(FOLDER_PATH, n))
                                if txt:
                                    context_docs.append(
                                        Document(page_content=txt, metadata={"source": n})
                                    )
                        final_context = "\n\n---\n\n".join(
                            f"ÿßŸÑŸÖÿµÿØÿ±: {doc.metadata['source']}\n\nÿßŸÑŸÖÿ≠ÿ™ŸàŸâ: {doc.page_content}"
                            for doc in context_docs
                        )
                else:
                    st.info("‚öôÔ∏è ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ ŸÖÿπÿ∑ŸÑ ‚Äì ÿ≥Ÿäÿ™ŸÖ ÿßŸÑÿßÿπÿ™ŸÖÿßÿØ ÿπŸÑŸâ ÿßŸÑŸÇŸàÿßÿπÿØ ŸÅŸÇÿ∑.")
                    final_context = ""

                # ---- Generate the answer ----
                with st.spinner("ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ±ÿØ‚Ä¶"):
                    task = "ÿ£ÿ¨ÿ® ÿπŸÜ ÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿßŸÑÿßÿπÿ™ŸÖÿßÿØ ÿπŸÑŸâ ÿßŸÑŸàÿ´ÿßÿ¶ŸÇ ŸÅŸÇÿ∑."
                    full_prompt = build_prompt(
                        task, st.session_state.rules_content, final_context, prompt
                    )
                    placeholder = st.empty()
                    answer = ""
                    history_for_api = [
                        {"role": m["role"], "content": m["content"]}
                        for m in st.session_state.messages[:-1]
                        if not m.get("is_review_notice")
                    ]
                    for chunk in get_deepseek_response_stream(
                        full_prompt, API_KEY, history_for_api, len(context_docs)
                    ):
                        answer += chunk
                        placeholder.markdown(answer + "‚ñå")
                    placeholder.markdown(answer)

                if answer:
                    st.session_state.messages.append(
                        {"role": "assistant", "content": answer}
                    )
                time.sleep(0.1)
                st.rerun()

    # --------------------------------------------------------------------- #
    # Footer ‚Äì quick actions
    # ---------------------------------------------------------------------- #
    with st.container():
        st.markdown('<div class="footer-actions">', unsafe_allow_html=True)
        st.markdown(
            '<div class="actions-header">ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™ ÿßŸÑÿ≥ÿ±Ÿäÿπÿ©</div>',
            unsafe_allow_html=True,
        )
        col1, col2, col3 = st.columns(3)

        if col1.button("üìÇ ÿ±ŸÅÿπ", use_container_width=True):
            st.session_state.action = "upload_doc"
            st.rerun()

        if col2.button("üìÑ ÿ™ŸÑÿÆŸäÿµ", use_container_width=True):
            st.session_state.action = "summarize_doc"
            st.rerun()

        if col3.button("üßπ ŸÖÿ≥ÿ≠", use_container_width=True):
            st.session_state.messages = []
            st.session_state.action = None
            st.toast("‚úÖ ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©", icon="üóëÔ∏è")
            st.rerun()

        st.markdown("</div>", unsafe_allow_html=True)


if __name__ == "__main__":
    main()